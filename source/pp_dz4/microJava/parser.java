
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Jan 23 18:44:40 CET 2011
//----------------------------------------------------

package microJava;

import java_cup.runtime.*;
import java.io.*;
import hashtable.*;
import symboltable.*;
import codeGeneration.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Jan 23 18:44:40 CET 2011
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\160\000\002\002\010\000\002\002\004\000\002\046" +
    "\003\000\002\003\004\000\002\003\002\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\033\003\000" +
    "\002\050\003\000\002\050\003\000\002\054\002\000\002" +
    "\005\011\000\002\005\005\000\002\006\007\000\002\006" +
    "\005\000\002\055\002\000\002\007\006\000\002\007\004" +
    "\000\002\010\005\000\002\010\003\000\002\011\005\000" +
    "\002\011\003\000\002\012\004\000\002\012\002\000\002" +
    "\013\004\000\002\013\002\000\002\047\004\000\002\047" +
    "\004\000\002\056\002\000\002\014\013\000\002\051\003" +
    "\000\002\051\002\000\002\052\005\000\002\052\003\000" +
    "\002\053\004\000\002\053\006\000\002\016\004\000\002" +
    "\016\002\000\002\017\003\000\002\017\003\000\002\017" +
    "\003\000\002\020\007\000\002\020\011\000\002\020\007" +
    "\000\002\021\003\000\002\021\004\000\002\021\004\000" +
    "\002\021\005\000\002\021\007\000\002\021\007\000\002" +
    "\021\011\000\002\021\005\000\002\021\011\000\002\021" +
    "\007\000\002\022\006\000\002\022\006\000\002\057\002" +
    "\000\002\022\010\000\002\022\005\000\002\022\005\000" +
    "\002\022\006\000\002\022\007\000\002\044\003\000\002" +
    "\045\005\000\002\060\002\000\002\045\007\000\002\045" +
    "\003\000\002\030\003\000\002\030\003\000\002\031\003" +
    "\000\002\031\003\000\002\031\003\000\002\032\003\000" +
    "\002\032\003\000\002\032\003\000\002\032\003\000\002" +
    "\032\003\000\002\032\003\000\002\015\003\000\002\035" +
    "\005\000\002\035\003\000\002\034\003\000\002\034\004" +
    "\000\002\036\005\000\002\036\003\000\002\037\003\000" +
    "\002\041\005\000\002\041\003\000\002\040\003\000\002" +
    "\040\003\000\002\040\005\000\002\040\003\000\002\040" +
    "\003\000\002\042\003\000\002\042\005\000\002\061\002" +
    "\000\002\042\007\000\002\042\006\000\002\043\004\000" +
    "\002\043\007\000\002\043\007\000\002\023\004\000\002" +
    "\023\003\000\002\023\003\000\002\024\005\000\002\024" +
    "\004\000\002\025\004\000\002\025\003\000\002\026\005" +
    "\000\002\026\004\000\002\027\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\312\000\004\005\005\001\002\000\004\002\314\001" +
    "\002\000\004\053\007\001\002\000\014\003\ufffd\005\ufffd" +
    "\006\ufffd\047\ufffd\053\ufffd\001\002\000\014\003\uffff\005" +
    "\uffff\006\uffff\047\uffff\053\uffff\001\002\000\014\003\017" +
    "\005\022\006\021\047\011\053\012\001\002\000\010\007" +
    "\uffe7\050\uffe7\053\uffe7\001\002\000\050\020\ufff9\021\ufff9" +
    "\022\ufff9\023\ufff9\024\ufff9\025\ufff9\026\ufff9\027\ufff9\030" +
    "\ufff9\031\ufff9\032\ufff9\033\ufff9\034\ufff9\040\ufff9\041\ufff9" +
    "\044\ufff9\045\ufff9\046\ufff9\053\ufff9\001\002\000\014\003" +
    "\ufffe\005\ufffe\006\ufffe\047\ufffe\053\ufffe\001\002\000\014" +
    "\003\ufffc\005\ufffc\006\ufffc\047\ufffc\053\ufffc\001\002\000" +
    "\014\003\ufffa\005\ufffa\006\ufffa\047\ufffa\053\ufffa\001\002" +
    "\000\004\053\ufff1\001\002\000\004\040\044\001\002\000" +
    "\014\003\ufffb\005\ufffb\006\ufffb\047\ufffb\053\ufffb\001\002" +
    "\000\006\003\032\053\012\001\002\000\006\003\023\053" +
    "\024\001\002\000\004\050\031\001\002\000\004\047\025" +
    "\001\002\000\010\003\uffe9\050\uffe9\053\uffe9\001\002\000" +
    "\010\003\017\050\027\053\012\001\002\000\014\003\ufff3" +
    "\005\ufff3\006\ufff3\047\ufff3\053\ufff3\001\002\000\012\003" +
    "\uffea\047\uffea\050\uffea\053\uffea\001\002\000\014\003\ufff2" +
    "\005\ufff2\006\ufff2\047\ufff2\053\ufff2\001\002\000\004\040" +
    "\043\001\002\000\004\053\ufff6\001\002\000\004\053\035" +
    "\001\002\000\004\035\036\001\002\000\006\051\037\052" +
    "\040\001\002\000\004\040\ufff8\001\002\000\004\040\ufff7" +
    "\001\002\000\004\040\042\001\002\000\014\003\ufff5\005" +
    "\ufff5\006\ufff5\047\ufff5\053\ufff5\001\002\000\014\003\ufff4" +
    "\005\ufff4\006\ufff4\047\ufff4\053\ufff4\001\002\000\016\003" +
    "\uffef\005\uffef\006\uffef\047\uffef\050\uffef\053\uffef\001\002" +
    "\000\004\053\047\001\002\000\006\040\054\041\053\001" +
    "\002\000\010\040\uffeb\041\uffeb\045\051\001\002\000\006" +
    "\040\uffed\041\uffed\001\002\000\004\046\052\001\002\000" +
    "\006\040\uffec\041\uffec\001\002\000\004\053\047\001\002" +
    "\000\016\003\ufff0\005\ufff0\006\ufff0\047\ufff0\050\ufff0\053" +
    "\ufff0\001\002\000\006\040\uffee\041\uffee\001\002\000\010" +
    "\007\063\050\062\053\012\001\002\000\010\007\uffe8\050" +
    "\uffe8\053\uffe8\001\002\000\004\053\313\001\002\000\004" +
    "\043\065\001\002\000\004\002\001\001\002\000\004\053" +
    "\064\001\002\000\004\043\uffe5\001\002\000\006\044\uffe4" +
    "\053\uffe4\001\002\000\006\044\uffe1\053\012\001\002\000" +
    "\004\053\310\001\002\000\004\044\075\001\002\000\006" +
    "\041\073\044\uffe2\001\002\000\006\041\uffdf\044\uffdf\001" +
    "\002\000\004\053\012\001\002\000\006\041\uffe0\044\uffe0" +
    "\001\002\000\010\003\uffe9\047\uffe9\053\uffe9\001\002\000" +
    "\010\003\017\047\077\053\012\001\002\000\026\003\uffdb" +
    "\010\uffdb\011\uffdb\013\uffdb\015\uffdb\016\uffdb\017\uffdb\047" +
    "\uffdb\050\uffdb\053\uffdb\001\002\000\026\003\113\010\114" +
    "\011\101\013\110\015\103\016\115\017\120\047\104\050" +
    "\116\053\106\001\002\000\004\043\304\001\002\000\026" +
    "\003\uffd9\010\uffd9\011\uffd9\013\uffd9\015\uffd9\016\uffd9\017" +
    "\uffd9\047\uffd9\050\uffd9\053\uffd9\001\002\000\004\043\277" +
    "\001\002\000\026\003\uffdb\010\uffdb\011\uffdb\013\uffdb\015" +
    "\uffdb\016\uffdb\017\uffdb\047\uffdb\050\uffdb\053\uffdb\001\002" +
    "\000\026\003\uffda\010\uffda\011\uffda\013\uffda\015\uffda\016" +
    "\uffda\017\uffda\047\uffda\050\uffda\053\uffda\001\002\000\060" +
    "\020\uffbe\021\uffbe\022\uffbe\023\uffbe\024\uffbe\025\uffbe\026" +
    "\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\034\uffbe" +
    "\035\uffbe\036\uffbe\037\uffbe\040\uffbe\041\uffbe\042\uffbe\043" +
    "\uffbe\044\uffbe\045\uffbe\046\uffbe\001\002\000\012\035\252" +
    "\036\253\037\254\043\255\001\002\000\004\043\214\001" +
    "\002\000\060\020\uffc2\021\uffc2\022\uffc2\023\uffc2\024\uffc2" +
    "\025\uffc2\026\uffc2\027\uffc2\030\uffc2\031\uffc2\032\uffc2\033" +
    "\uffc2\034\uffc2\035\uffc2\036\uffc2\037\uffc2\040\uffc2\041\uffc2" +
    "\042\207\043\uffc2\044\uffc2\045\206\046\uffc2\001\002\000" +
    "\026\003\uffdc\010\uffdc\011\uffdc\013\uffdc\015\uffdc\016\uffdc" +
    "\017\uffdc\047\uffdc\050\uffdc\053\uffdc\001\002\000\026\003" +
    "\uffd8\010\uffd8\011\uffd8\013\uffd8\015\uffd8\016\uffd8\017\uffd8" +
    "\047\uffd8\050\uffd8\053\uffd8\001\002\000\004\043\176\001" +
    "\002\000\020\012\124\021\122\040\130\043\137\051\125" +
    "\052\132\053\106\001\002\000\010\007\uffe3\050\uffe3\053" +
    "\uffe3\001\002\000\030\003\uffd4\010\uffd4\011\uffd4\013\uffd4" +
    "\014\uffd4\015\uffd4\016\uffd4\017\uffd4\047\uffd4\050\uffd4\053" +
    "\uffd4\001\002\000\004\040\121\001\002\000\030\003\uffd3" +
    "\010\uffd3\011\uffd3\013\uffd3\014\uffd3\015\uffd3\016\uffd3\017" +
    "\uffd3\047\uffd3\050\uffd3\053\uffd3\001\002\000\014\012\124" +
    "\043\137\051\125\052\132\053\106\001\002\000\044\020" +
    "\uffa5\021\uffa5\022\uffa5\023\uffa5\024\uffa5\025\uffa5\026\uffa5" +
    "\027\uffa5\030\uffa5\031\uffa5\032\uffa5\033\uffa5\034\uffa5\040" +
    "\uffa5\041\uffa5\044\uffa5\046\uffa5\001\002\000\004\053\012" +
    "\001\002\000\044\020\uffa8\021\uffa8\022\uffa8\023\uffa8\024" +
    "\uffa8\025\uffa8\026\uffa8\027\uffa8\030\uffa8\031\uffa8\032\uffa8" +
    "\033\uffa8\034\uffa8\040\uffa8\041\uffa8\044\uffa8\046\uffa8\001" +
    "\002\000\036\020\uffac\021\uffac\025\uffac\026\uffac\027\uffac" +
    "\030\uffac\031\uffac\032\uffac\033\uffac\034\uffac\040\uffac\041" +
    "\uffac\044\uffac\046\uffac\001\002\000\046\020\uffa3\021\uffa3" +
    "\022\uffa3\023\uffa3\024\uffa3\025\uffa3\026\uffa3\027\uffa3\030" +
    "\uffa3\031\uffa3\032\uffa3\033\uffa3\034\uffa3\040\uffa3\041\uffa3" +
    "\043\154\044\uffa3\046\uffa3\001\002\000\030\003\uffd2\010" +
    "\uffd2\011\uffd2\013\uffd2\014\uffd2\015\uffd2\016\uffd2\017\uffd2" +
    "\047\uffd2\050\uffd2\053\uffd2\001\002\000\044\020\uffa4\021" +
    "\uffa4\022\uffa4\023\uffa4\024\uffa4\025\uffa4\026\uffa4\027\uffa4" +
    "\030\uffa4\031\uffa4\032\uffa4\033\uffa4\034\uffa4\040\uffa4\041" +
    "\uffa4\044\uffa4\046\uffa4\001\002\000\044\020\uffa7\021\uffa7" +
    "\022\uffa7\023\uffa7\024\uffa7\025\uffa7\026\uffa7\027\uffa7\030" +
    "\uffa7\031\uffa7\032\uffa7\033\uffa7\034\uffa7\040\uffa7\041\uffa7" +
    "\044\uffa7\046\uffa7\001\002\000\036\020\151\021\152\025" +
    "\uffaf\026\uffaf\027\uffaf\030\uffaf\031\uffaf\032\uffaf\033\uffaf" +
    "\034\uffaf\040\uffaf\041\uffaf\044\uffaf\046\uffaf\001\002\000" +
    "\044\020\uffa9\021\uffa9\022\uffa9\023\uffa9\024\uffa9\025\uffa9" +
    "\026\uffa9\027\uffa9\030\uffa9\031\uffa9\032\uffa9\033\uffa9\034" +
    "\uffa9\040\uffa9\041\uffa9\044\uffa9\046\uffa9\001\002\000\004" +
    "\040\147\001\002\000\044\020\uffab\021\uffab\022\145\023" +
    "\144\024\142\025\uffab\026\uffab\027\uffab\030\uffab\031\uffab" +
    "\032\uffab\033\uffab\034\uffab\040\uffab\041\uffab\044\uffab\046" +
    "\uffab\001\002\000\016\012\124\021\122\043\137\051\125" +
    "\052\132\053\106\001\002\000\004\044\141\001\002\000" +
    "\044\020\uffa6\021\uffa6\022\uffa6\023\uffa6\024\uffa6\025\uffa6" +
    "\026\uffa6\027\uffa6\030\uffa6\031\uffa6\032\uffa6\033\uffa6\034" +
    "\uffa6\040\uffa6\041\uffa6\044\uffa6\046\uffa6\001\002\000\014" +
    "\012\uffb9\043\uffb9\051\uffb9\052\uffb9\053\uffb9\001\002\000" +
    "\014\012\124\043\137\051\125\052\132\053\106\001\002" +
    "\000\014\012\uffba\043\uffba\051\uffba\052\uffba\053\uffba\001" +
    "\002\000\014\012\uffbb\043\uffbb\051\uffbb\052\uffbb\053\uffbb" +
    "\001\002\000\044\020\uffaa\021\uffaa\022\uffaa\023\uffaa\024" +
    "\uffaa\025\uffaa\026\uffaa\027\uffaa\030\uffaa\031\uffaa\032\uffaa" +
    "\033\uffaa\034\uffaa\040\uffaa\041\uffaa\044\uffaa\046\uffaa\001" +
    "\002\000\030\003\uffd1\010\uffd1\011\uffd1\013\uffd1\014\uffd1" +
    "\015\uffd1\016\uffd1\017\uffd1\047\uffd1\050\uffd1\053\uffd1\001" +
    "\002\000\014\012\124\043\137\051\125\052\132\053\106" +
    "\001\002\000\014\012\uffbd\043\uffbd\051\uffbd\052\uffbd\053" +
    "\uffbd\001\002\000\014\012\uffbc\043\uffbc\051\uffbc\052\uffbc" +
    "\053\uffbc\001\002\000\036\020\uffad\021\uffad\025\uffad\026" +
    "\uffad\027\uffad\030\uffad\031\uffad\032\uffad\033\uffad\034\uffad" +
    "\040\uffad\041\uffad\044\uffad\046\uffad\001\002\000\022\003" +
    "\156\012\uffa1\021\uffa1\043\uffa1\044\155\051\uffa1\052\uffa1" +
    "\053\uffa1\001\002\000\044\020\uffa2\021\uffa2\022\uffa2\023" +
    "\uffa2\024\uffa2\025\uffa2\026\uffa2\027\uffa2\030\uffa2\031\uffa2" +
    "\032\uffa2\033\uffa2\034\uffa2\040\uffa2\041\uffa2\044\uffa2\046" +
    "\uffa2\001\002\000\004\044\166\001\002\000\016\012\124" +
    "\021\122\043\137\051\125\052\132\053\106\001\002\000" +
    "\006\041\164\044\uffb2\001\002\000\006\041\uffb0\044\uffb0" +
    "\001\002\000\004\044\163\001\002\000\044\020\uffa0\021" +
    "\uffa0\022\uffa0\023\uffa0\024\uffa0\025\uffa0\026\uffa0\027\uffa0" +
    "\030\uffa0\031\uffa0\032\uffa0\033\uffa0\034\uffa0\040\uffa0\041" +
    "\uffa0\044\uffa0\046\uffa0\001\002\000\016\012\124\021\122" +
    "\043\137\051\125\052\132\053\106\001\002\000\006\041" +
    "\uffb1\044\uffb1\001\002\000\044\020\uff9f\021\uff9f\022\uff9f" +
    "\023\uff9f\024\uff9f\025\uff9f\026\uff9f\027\uff9f\030\uff9f\031" +
    "\uff9f\032\uff9f\033\uff9f\034\uff9f\040\uff9f\041\uff9f\044\uff9f" +
    "\046\uff9f\001\002\000\046\020\uff9e\021\uff9e\022\uff9e\023" +
    "\uff9e\024\uff9e\025\uff9e\026\uff9e\027\uff9e\030\uff9e\031\uff9e" +
    "\032\uff9e\033\uff9e\034\uff9e\040\uff9e\041\uff9e\044\uff9e\045" +
    "\170\046\uff9e\001\002\000\020\003\171\012\124\021\122" +
    "\043\137\051\125\052\132\053\106\001\002\000\004\046" +
    "\174\001\002\000\004\046\173\001\002\000\044\020\uff9d" +
    "\021\uff9d\022\uff9d\023\uff9d\024\uff9d\025\uff9d\026\uff9d\027" +
    "\uff9d\030\uff9d\031\uff9d\032\uff9d\033\uff9d\034\uff9d\040\uff9d" +
    "\041\uff9d\044\uff9d\046\uff9d\001\002\000\044\020\uff9c\021" +
    "\uff9c\022\uff9c\023\uff9c\024\uff9c\025\uff9c\026\uff9c\027\uff9c" +
    "\030\uff9c\031\uff9c\032\uff9c\033\uff9c\034\uff9c\040\uff9c\041" +
    "\uff9c\044\uff9c\046\uff9c\001\002\000\036\020\151\021\152" +
    "\025\uffae\026\uffae\027\uffae\030\uffae\031\uffae\032\uffae\033" +
    "\uffae\034\uffae\040\uffae\041\uffae\044\uffae\046\uffae\001\002" +
    "\000\016\012\124\021\122\043\137\051\125\052\132\053" +
    "\106\001\002\000\006\041\200\044\201\001\002\000\004" +
    "\051\203\001\002\000\004\040\202\001\002\000\030\003" +
    "\uffcf\010\uffcf\011\uffcf\013\uffcf\014\uffcf\015\uffcf\016\uffcf" +
    "\017\uffcf\047\uffcf\050\uffcf\053\uffcf\001\002\000\004\044" +
    "\204\001\002\000\004\040\205\001\002\000\030\003\uffce" +
    "\010\uffce\011\uffce\013\uffce\014\uffce\015\uffce\016\uffce\017" +
    "\uffce\047\uffce\050\uffce\053\uffce\001\002\000\016\012\uffc0" +
    "\021\uffc0\043\uffc0\051\uffc0\052\uffc0\053\uffc0\001\002\000" +
    "\004\053\210\001\002\000\060\020\uffc1\021\uffc1\022\uffc1" +
    "\023\uffc1\024\uffc1\025\uffc1\026\uffc1\027\uffc1\030\uffc1\031" +
    "\uffc1\032\uffc1\033\uffc1\034\uffc1\035\uffc1\036\uffc1\037\uffc1" +
    "\040\uffc1\041\uffc1\042\uffc1\043\uffc1\044\uffc1\045\uffc1\046" +
    "\uffc1\001\002\000\016\012\124\021\122\043\137\051\125" +
    "\052\132\053\106\001\002\000\004\046\213\001\002\000" +
    "\060\020\uffbf\021\uffbf\022\uffbf\023\uffbf\024\uffbf\025\uffbf" +
    "\026\uffbf\027\uffbf\030\uffbf\031\uffbf\032\uffbf\033\uffbf\034" +
    "\uffbf\035\uffbf\036\uffbf\037\uffbf\040\uffbf\041\uffbf\042\uffbf" +
    "\043\uffbf\044\uffbf\045\uffbf\046\uffbf\001\002\000\020\003" +
    "\220\012\124\021\122\043\137\051\125\052\132\053\106" +
    "\001\002\000\016\025\246\026\242\027\243\030\245\031" +
    "\247\032\250\001\002\000\010\033\235\034\uff95\044\uff95" +
    "\001\002\000\004\044\227\001\002\000\004\044\uff99\001" +
    "\002\000\006\034\223\044\uff9a\001\002\000\006\034\225" +
    "\044\uff9b\001\002\000\016\012\124\021\122\043\137\051" +
    "\125\052\132\053\106\001\002\000\006\034\uff97\044\uff97" +
    "\001\002\000\016\012\124\021\122\043\137\051\125\052" +
    "\132\053\106\001\002\000\006\034\uff98\044\uff98\001\002" +
    "\000\024\003\113\010\114\011\101\013\110\015\103\016" +
    "\115\017\120\047\104\053\106\001\002\000\030\003\uffda" +
    "\010\uffda\011\uffda\013\uffda\014\232\015\uffda\016\uffda\017" +
    "\uffda\047\uffda\050\uffda\053\uffda\001\002\000\026\003\uffd7" +
    "\010\uffd7\011\uffd7\013\uffd7\015\uffd7\016\uffd7\017\uffd7\047" +
    "\uffd7\050\uffd7\053\uffd7\001\002\000\022\010\114\011\101" +
    "\013\110\015\103\016\115\017\120\047\104\053\106\001" +
    "\002\000\026\003\uffd6\010\uffd6\011\uffd6\013\uffd6\015\uffd6" +
    "\016\uffd6\017\uffd6\047\uffd6\050\uffd6\053\uffd6\001\002\000" +
    "\030\003\uffcc\010\uffcc\011\uffcc\013\uffcc\014\uffcc\015\uffcc" +
    "\016\uffcc\017\uffcc\047\uffcc\050\uffcc\053\uffcc\001\002\000" +
    "\016\012\124\021\122\043\137\051\125\052\132\053\106" +
    "\001\002\000\010\033\237\034\uff96\044\uff96\001\002\000" +
    "\016\012\124\021\122\043\137\051\125\052\132\053\106" +
    "\001\002\000\010\033\uff94\034\uff94\044\uff94\001\002\000" +
    "\010\033\uff93\034\uff93\044\uff93\001\002\000\016\012\uffb7" +
    "\021\uffb7\043\uffb7\051\uffb7\052\uffb7\053\uffb7\001\002\000" +
    "\016\012\uffb6\021\uffb6\043\uffb6\051\uffb6\052\uffb6\053\uffb6" +
    "\001\002\000\016\012\124\021\122\043\137\051\125\052" +
    "\132\053\106\001\002\000\016\012\uffb5\021\uffb5\043\uffb5" +
    "\051\uffb5\052\uffb5\053\uffb5\001\002\000\016\012\uffb8\021" +
    "\uffb8\043\uffb8\051\uffb8\052\uffb8\053\uffb8\001\002\000\016" +
    "\012\uffb4\021\uffb4\043\uffb4\051\uffb4\052\uffb4\053\uffb4\001" +
    "\002\000\016\012\uffb3\021\uffb3\043\uffb3\051\uffb3\052\uffb3" +
    "\053\uffb3\001\002\000\010\033\uff92\034\uff92\044\uff92\001" +
    "\002\000\020\003\271\012\124\021\122\043\137\051\125" +
    "\052\132\053\106\001\002\000\004\040\270\001\002\000" +
    "\004\040\267\001\002\000\022\003\260\012\uffc8\021\uffc8" +
    "\043\uffc8\044\257\051\uffc8\052\uffc8\053\uffc8\001\002\000" +
    "\016\012\124\021\122\043\137\051\125\052\132\053\106" +
    "\001\002\000\004\040\263\001\002\000\004\044\261\001" +
    "\002\000\004\040\262\001\002\000\030\003\uffc3\010\uffc3" +
    "\011\uffc3\013\uffc3\014\uffc3\015\uffc3\016\uffc3\017\uffc3\047" +
    "\uffc3\050\uffc3\053\uffc3\001\002\000\030\003\uffc9\010\uffc9" +
    "\011\uffc9\013\uffc9\014\uffc9\015\uffc9\016\uffc9\017\uffc9\047" +
    "\uffc9\050\uffc9\053\uffc9\001\002\000\004\044\265\001\002" +
    "\000\004\040\266\001\002\000\030\003\uffc7\010\uffc7\011" +
    "\uffc7\013\uffc7\014\uffc7\015\uffc7\016\uffc7\017\uffc7\047\uffc7" +
    "\050\uffc7\053\uffc7\001\002\000\030\003\uffc5\010\uffc5\011" +
    "\uffc5\013\uffc5\014\uffc5\015\uffc5\016\uffc5\017\uffc5\047\uffc5" +
    "\050\uffc5\053\uffc5\001\002\000\030\003\uffc6\010\uffc6\011" +
    "\uffc6\013\uffc6\014\uffc6\015\uffc6\016\uffc6\017\uffc6\047\uffc6" +
    "\050\uffc6\053\uffc6\001\002\000\004\040\274\001\002\000" +
    "\004\040\273\001\002\000\030\003\uffca\010\uffca\011\uffca" +
    "\013\uffca\014\uffca\015\uffca\016\uffca\017\uffca\047\uffca\050" +
    "\uffca\053\uffca\001\002\000\030\003\uffc4\010\uffc4\011\uffc4" +
    "\013\uffc4\014\uffc4\015\uffc4\016\uffc4\017\uffc4\047\uffc4\050" +
    "\uffc4\053\uffc4\001\002\000\026\003\113\010\114\011\101" +
    "\013\110\015\103\016\115\017\120\047\104\050\276\053" +
    "\106\001\002\000\030\003\uffcd\010\uffcd\011\uffcd\013\uffcd" +
    "\014\uffcd\015\uffcd\016\uffcd\017\uffcd\047\uffcd\050\uffcd\053" +
    "\uffcd\001\002\000\020\003\220\012\124\021\122\043\137" +
    "\051\125\052\132\053\106\001\002\000\004\044\301\001" +
    "\002\000\022\010\114\011\101\013\110\015\103\016\115" +
    "\017\120\047\104\053\106\001\002\000\026\003\uffd5\010" +
    "\uffd5\011\uffd5\013\uffd5\015\uffd5\016\uffd5\017\uffd5\047\uffd5" +
    "\050\uffd5\053\uffd5\001\002\000\030\003\uffcb\010\uffcb\011" +
    "\uffcb\013\uffcb\014\uffcb\015\uffcb\016\uffcb\017\uffcb\047\uffcb" +
    "\050\uffcb\053\uffcb\001\002\000\004\053\106\001\002\000" +
    "\004\044\306\001\002\000\004\040\307\001\002\000\030" +
    "\003\uffd0\010\uffd0\011\uffd0\013\uffd0\014\uffd0\015\uffd0\016" +
    "\uffd0\017\uffd0\047\uffd0\050\uffd0\053\uffd0\001\002\000\010" +
    "\041\uffde\044\uffde\045\311\001\002\000\004\046\312\001" +
    "\002\000\006\041\uffdd\044\uffdd\001\002\000\004\043\uffe6" +
    "\001\002\000\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\312\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\046\005\001\001\000\004\003\007\001\001\000\002" +
    "\001\001\000\014\004\012\005\013\006\017\007\014\033" +
    "\015\001\001\000\004\013\055\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\055\044\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\033\032\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\012\025\001\001\000\006" +
    "\007\027\033\015\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\054\033" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\050" +
    "\040\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\010\045\011\047\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\011\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\014\056\033\057\047\060\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\056\065\001\001\000\012\033\066\051\067\052\070" +
    "\053\071\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\033\066\053\073" +
    "\001\001\000\002\001\001\000\004\012\075\001\001\000" +
    "\006\007\027\033\015\001\001\000\004\016\077\001\001" +
    "\000\016\017\111\020\101\021\104\022\116\044\106\045" +
    "\110\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\016\274\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\034\134\036\132\037\125\040\133\041\135" +
    "\042\130\043\122\044\126\045\110\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\022\036\174\037\125\040\133\041\135\042\130\043" +
    "\122\044\126\045\110\001\001\000\002\001\001\000\004" +
    "\033\166\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\030\147\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\031\142\001\001\000\024\034\137" +
    "\036\132\037\125\040\133\041\135\042\130\043\122\044" +
    "\126\045\110\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\040\145\042\130\043\122\044" +
    "\126\045\110\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\020\037\152\040" +
    "\133\041\135\042\130\043\122\044\126\045\110\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\061\156\001\001\000\002\001\001\000\002\001\001" +
    "\000\030\015\161\034\160\035\157\036\132\037\125\040" +
    "\133\041\135\042\130\043\122\044\126\045\110\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\034\164\036\132\037\125\040\133" +
    "\041\135\042\130\043\122\044\126\045\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\024" +
    "\034\171\036\132\037\125\040\133\041\135\042\130\043" +
    "\122\044\126\045\110\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\030" +
    "\147\001\001\000\024\034\176\036\132\037\125\040\133" +
    "\041\135\042\130\043\122\044\126\045\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\060\210\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\034\211\036\132\037\125\040\133\041" +
    "\135\042\130\043\122\044\126\045\110\001\001\000\002" +
    "\001\001\000\002\001\001\000\032\023\216\025\220\027" +
    "\215\034\214\036\132\037\125\040\133\041\135\042\130" +
    "\043\122\044\126\045\110\001\001\000\004\032\243\001" +
    "\001\000\004\026\235\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\024\221\001\001\000\002\001\001\000" +
    "\030\025\223\027\215\034\214\036\132\037\125\040\133" +
    "\041\135\042\130\043\122\044\126\045\110\001\001\000" +
    "\002\001\001\000\030\025\225\027\215\034\214\036\132" +
    "\037\125\040\133\041\135\042\130\043\122\044\126\045" +
    "\110\001\001\000\002\001\001\000\016\017\230\020\101" +
    "\021\227\022\116\044\106\045\110\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\020\232\021\233\022\116" +
    "\044\106\045\110\001\001\000\002\001\001\000\002\001" +
    "\001\000\026\027\240\034\214\036\132\037\125\040\133" +
    "\041\135\042\130\043\122\044\126\045\110\001\001\000" +
    "\002\001\001\000\026\027\237\034\214\036\132\037\125" +
    "\040\133\041\135\042\130\043\122\044\126\045\110\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\034\250\036\132\037\125\040" +
    "\133\041\135\042\130\043\122\044\126\045\110\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\024\034\271\036\132" +
    "\037\125\040\133\041\135\042\130\043\122\044\126\045" +
    "\110\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\057\255\001\001\000\030\015\263\034\160\035\157\036" +
    "\132\037\125\040\133\041\135\042\130\043\122\044\126" +
    "\045\110\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\017\111\020" +
    "\101\021\104\022\116\044\106\045\110\001\001\000\002" +
    "\001\001\000\032\023\277\025\220\027\215\034\214\036" +
    "\132\037\125\040\133\041\135\042\130\043\122\044\126" +
    "\045\110\001\001\000\002\001\001\000\014\020\301\021" +
    "\302\022\116\044\106\045\110\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\044\304\045\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
		classNum = 0;
		mainClassMethodNum = 0;
		globalVarNum = 0;
		globalConstNum = 0;
		globalArrayNum = 0;
		mainVarNum = 0;
		mainStatmentNum = 0;
		mainFunctionCallNum = 0;
		varNum = 0;
		arrayNum = 0;
		formParsNum = 0;
		actParsNum = 0;

		mainMethod = true;
		innerClass = false;
		greska = false;
	    
    }


	
    //for counting
    static int classNum, mainClassMethodNum, globalVarNum, globalConstNum, 
		globalArrayNum, mainVarNum, mainStatmentNum, mainFunctionCallNum;
    static int varNum, arrayNum, formParsNum, actParsNum;

    static boolean mainMethod, innerClass;
        
    // sluzi da na kraju parsiranja znamo da li su se pojavljivale
    // greske tokom parsiranja
    boolean greska; 
    
    // glavni program, kao metod klase parser
    public static void main(String args[]) throws Exception {
        FileReader r = new FileReader(args[0]);
        Lexer skener = new Lexer(r);
        parser p = new parser(skener);
        /******************************************************************
        * Staticka metoda init tabele simbola sluzi za pocetno pravljenje 
        * tabele simbola, odnosno "universe" opsega.
        ******************************************************************/
    	 Tab.init();
    	 Symbol s = p.parse();  //pocetak parsiranja
		
		/*****************************************************************
		* Ukoliko ulazni program ima gresaka ispisemo upozorenje i
		* tabelu sintksne analize
		*****************************************************************/
        if (p.greska) System.out.println("Ulazni program ima gresaka!");
        else System.out.println("Parsiranje uspesno zavrseno!");
        parser_out();
        
        /*****************************************************************
        * Po zavrsetku analize, pozivom metode dump(), vrsimo ispis 
        * sadrzaja tabele simbola.
        *****************************************************************/ 
    	Tab.dump();
        
    }
  
    /***********************************************************************
    * slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    ***********************************************************************/ 
    public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

  public void report_error(String message, Object info)
    {
      greska=true;
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
          System.err.println(" na liniji " + ((Symbol)info).left);
      else System.err.println("");
    }

  private static void parser_out(){
		System.out.println("==================SYNTAX ANALYSIS====================");
		System.out.println(classNum + "\tclasses");
		System.out.println(mainClassMethodNum + "\tmethods in the program");
		System.out.println(globalVarNum + "\tglobal variables");
		System.out.println(globalConstNum + "\tglobal constants");
		System.out.println(globalArrayNum + "\tglobal arrays");
		System.out.println(mainVarNum + "\tlocal variables in main");
		System.out.println(mainStatmentNum + "\tstatements in main");
		System.out.println(mainFunctionCallNum + "\tfunction calls in main");
	}



}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


    	/*****************************************************************
    	* Sledece promenljive ce biti vidljive iz akcija u svim 
    	* smenama. var_type sluzi za cuvanje cvora Struct koji 
    	* odgovara tipu na pocetku deklaracije grupe promenljivih.
    	* isVoid je logicka promenljiva koja ima vrednost true ako
    	* je povratni tip metode void. returnExists je logicka 
    	* promenljiva koja ima vrednost true ako metoda ima 
    	* return iskaz.
    	*****************************************************************/ 
    	Struct var_type=Tab.noType;
		Struct form_param_type=Tab.noType;
    	Struct method_type=Tab.noType;
		HashTable actParamList = null;
    	boolean isVoid=false, returnExists=false; 

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // condFact ::= expr relop expr 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct o = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		if ( t.compatibleWith(o) ) {
			//TO DO
			//code generation
			//Code.store(o);
			
		}
		else
			parser.report_error("Greska u liniji "+oleft+": nekompatibilni tipovi za dodelu",null);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condFact",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // ANDcondFact_list ::= AND condFact 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ANDcondFact_list",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // ANDcondFact_list ::= ANDcondFact_list AND condFact 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ANDcondFact_list",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // condTerm ::= condFact 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("condTerm",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // condTerm ::= condFact ANDcondFact_list 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		parser.report_error("Greska u liniji "+oleft+": nisu dozvoljeni logicki uslovi",null); 
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condTerm",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // ORcondTerm_list ::= OR condTerm 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ORcondTerm_list",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // ORcondTerm_list ::= ORcondTerm_list OR condTerm 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ORcondTerm_list",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // cond ::= error 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do ) u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cond",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // cond ::= condTerm 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cond",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // cond ::= condTerm ORcondTerm_list 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		parser.report_error("Greska u liniji "+oleft+": nisu dozvoljeni logicki uslovi",null); 
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cond",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // new_expr ::= NEW type LSQUARE error RSQUARE 
            {
              Struct RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do ] u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_expr",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // new_expr ::= NEW type LSQUARE expr RSQUARE 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t1 = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		  if ( t1 != Tab.intType)
					parser.report_error("Greska u liniji "+tleft+": velicina niza mora biti tipa int",null);
				//Code.put(Code.newarray);
				//if ( t == Tab.charType ) Code.put(0); 
				//else Code.put(1);
				RESULT=new Struct(Struct.Array, t);
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_expr",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // new_expr ::= NEW type 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				if(t.getKind() != Struct.Class){
					parser.report_error("Greska u liniji "+tleft+": tip mora biti klasa",null);
				}
				RESULT = Tab.nullType;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_expr",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // des_paren ::= designator LPAREN error RPAREN 
            {
              Struct RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do ) u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("des_paren",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // des_paren ::= designator LPAREN NT$5 act_pars RPAREN 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
				if(parser.mainMethod) {
					parser.mainStatmentNum--;
					parser.mainFunctionCallNum++;
				}
				
				if (o.getKind()!=Obj.Meth )
                           parser.report_error("Greska u liniji "+oleft+": Ocekivan metod",null);
				if (o.getType()==Tab.noType )
                           parser.report_error("Greska u liniji "+oleft+": Procedura pozvana kao funkcija",null);
						   
				actParamList = null;
				
				RESULT=o.getType(); 
		   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("des_paren",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // NT$5 ::= 
            {
              Struct RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

				parser.actParsNum = 0;
		
				actParamList = o.getLocals();
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // des_paren ::= designator LPAREN RPAREN 
            {
              Struct RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
				if(parser.mainMethod) {
					parser.mainStatmentNum--;
					parser.mainFunctionCallNum++;
				}
				
				if (o.getKind()!=Obj.Meth )
                           parser.report_error("Greska u liniji "+oleft+": Ocekivan metod",null);
				if (o.getType()==Tab.noType )
                           parser.report_error("Greska u liniji "+oleft+": Procedura pozvana kao funkcija",null);
				
				//int dest_adr=o.adr-Code.pc; // racunanje relativne adrese
				//Code.put(Code.call);
				//Code.put2(dest_adr);
				RESULT=o.getType(); 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("des_paren",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // des_paren ::= designator 
            {
              Struct RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  if ( o.getKind()!=Obj.Var && o.getKind()!=Obj.Elem && o.getKind()!=Obj.Con)
                             parser.report_error("Greska u liniji "+oleft+": Ocekivana promenljiva,konstanta ili element niza",null);
				//Code.load(o);
				
				RESULT=o.getType();
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("des_paren",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // factor ::= des_paren 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // factor ::= new_expr 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // factor ::= LPAREN expr RPAREN 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // factor ::= CHARCONST 
            {
              Struct RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Character c = (Character)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	Obj o = new Obj(Obj.Con, "", Tab.charType);
				//o.adr=c.charValue(); Code.load(o); 
				RESULT=Tab.charType; 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // factor ::= NUMBER 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	Obj c = new Obj(Obj.Con, "", Tab.intType);
				//c.adr=i.intValue(); Code.load(c); 
				RESULT=Tab.intType; 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // factor_list ::= factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor_list",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // factor_list ::= factor_list mulop factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t1 = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
				if(t.getKind() != Struct.Int || t1.getKind() != Struct.Int){
					parser.report_error("Greska u liniji "+tleft+": oba operanda moraju biti tipa int",null);
				}
				RESULT=Tab.intType; 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor_list",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // term ::= factor_list 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // term_list ::= term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term_list",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // term_list ::= term_list addop term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t1 = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
				if(t.getKind() != Struct.Int || t1.getKind() != Struct.Int){
					parser.report_error("Greska u liniji "+tleft+": oba operanda moraju biti tipa int",null);
				}
				RESULT=Tab.intType; 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term_list",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // expr ::= MINUS term_list 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			if(t.getKind() != Struct.Int){
			 parser.report_error("Greska u liniji "+tleft+": desni operand mora biti tipa int",null);
			}
			
			if(actParamList != null){	
				if(actParamList.getNumOfElem() < parser.actParsNum)
					parser.report_error("Greska u liniji "+tleft+": broj parametara se razlikuje",null);
				else{
					boolean found = false;
					
					for (int i = 0; i < actParamList.getTable().length && actParamList != null; i++) {
						Obj o = (Obj) actParamList.getHashNode(i);
					
						while(o!= null){
							
							for(int j = 0; j<actParamList.getNumOfElem(); j++){
								if(o.getFpPos() == j && o.getType().getKind() == t.getKind()){
									found = true;
									break;
								}
							}
							if(found) break;
							o = (Obj)o.getNext();
						}
			
						if(found) break;
					}
		
					if(!found) {
						parser.report_error("Greska u liniji "+tleft+": nekompatibilni tipovi pri pozivu metode",null);
					}
				}
			}
			RESULT=t; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // expr ::= term_list 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		if(actParamList != null){	
				
				
					boolean found = false;
					
					for (int i = 0; i < actParamList.getTable().length && actParamList != null; i++) {
						Obj o = (Obj) actParamList.getHashNode(i);
					
						while(o!= null){
							
							for(int j = 0; j<actParamList.getNumOfElem(); j++){
								if(o.getFpPos() == j && o.getType().getKind() == t.getKind()){
									found = true;
									break;
								}
							}
							if(found) break;
							o = (Obj)o.getNext();
						}
			
						if(found) break;
					}
		
					if(!found) {
						parser.report_error("Greska u liniji "+tleft+": nekompatibilni tipovi pri pozivu metode",null);
					}
		}
		RESULT=t;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expr",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // expr_list ::= expr 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				
				parser.actParsNum++;
				
				RESULT = t;
		  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expr_list",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // expr_list ::= expr_list COMMA expr 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
				parser.actParsNum++;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expr_list",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // act_pars ::= expr_list 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		if(actParamList.getNumOfElem() != parser.actParsNum)
					parser.report_error("Greska u liniji "+tleft+": broj parametara se razlikuje",null);
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("act_pars",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // relop ::= LESS_EQUAL 
            {
              Object RESULT =null;
		 RESULT = Code.le; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // relop ::= LESS 
            {
              Object RESULT =null;
		 RESULT = Code.lt; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // relop ::= GREATER_EQUAL 
            {
              Object RESULT =null;
		 RESULT = Code.ge; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // relop ::= GREATER 
            {
              Object RESULT =null;
		 RESULT = Code.gt; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // relop ::= NOT_EQUAL 
            {
              Object RESULT =null;
		 RESULT = Code.ne; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // relop ::= EQUAL 
            {
              Object RESULT =null;
		 RESULT = Code.eq; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // mulop ::= MOD 
            {
              Object RESULT =null;
		 RESULT = Code.rem; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // mulop ::= DIV 
            {
              Object RESULT =null;
		 RESULT = Code.div; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // mulop ::= TIMES 
            {
              Object RESULT =null;
		 RESULT = Code.mul; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // addop ::= MINUS 
            {
              Object RESULT =null;
		 RESULT = Code.sub; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // addop ::= PLUS 
            {
              Object RESULT =null;
		 RESULT = Code.add; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // ident_expr_list ::= IDENT 
            {
              Obj RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Obj ob=Tab.find(id); // find prijavljuje
                                            // gresku u slucaju da ne nadje
			if (ob != Tab.noObj) 
				System.out.println("Pretraga "+idleft+" ("+id+"), nadjeno "+ob); 
			RESULT=ob; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // ident_expr_list ::= ident_expr_list LSQUARE NT$4 expr RSQUARE 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Obj id = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
        	if (id.getType().getKind()!=Struct.Array) {
				parser.report_error("Greska u liniji "+idleft+": Ocekivan niz",null);
				RESULT=id;
			}
			
			if(t.getKind() != Struct.Int){
				parser.report_error("Greska u liniji "+tleft+": izraz unutar zagrada mora biti int",null);
			}
			
			
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$4 ::= 
            {
              Obj RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Obj id = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
 	if (id.getType().getKind()==Struct.Array){
				// generisanje koda 
				//Code.load(id);
				// dalje prenosimo element niza
				RESULT=new Obj(Obj.Elem, "", id.getType().getElemType());
			}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // ident_expr_list ::= ident_expr_list DOT IDENT 
            {
              Obj RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			
			if(o.getType().getKind() != Struct.Class){
      			parser.report_error("Greska u liniji "+oleft+": tip mora biti klasa",null);
				
				RESULT = new Obj(Obj.Fld, id, Tab.noType);
      		} else {
      		
				HashTable locals = o.getLocals();
				Obj node = (Obj)locals.searchKey(id); 
				if(node == null){
					parser.report_error("Greska u liniji "+oleft+": nije polje unutar klase",null);
				}
      		
				RESULT = node;
			}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // designator ::= ident_expr_list 
            {
              Obj RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=o; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // designator_stmt ::= designator LPAREN error RPAREN SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 parser.report_error("Izvrsen oporavak do ) u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // designator_stmt ::= designator ASSIGNMENT error SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do ; u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // designator_stmt ::= designator DEC SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		if(t.getKind() == Obj.Elem || t.getKind() == Obj.Var){
			if (t.getType() != Tab.intType ) {
				parser.report_error("Greska u liniji "+tleft+": tip promenljive mora biti int",null);
			}
		} else
			parser.report_error("Greska u liniji "+tleft+": levi operand mora oznacavati promenljivu, element niza ili polje unutar objekta",null);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // designator_stmt ::= designator INC SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		if(t.getKind() == Obj.Elem || t.getKind() == Obj.Var){
			if (t.getType() != Tab.intType ) {
				parser.report_error("Greska u liniji "+tleft+": tip promenljive mora biti int",null);
			}
		} else
			parser.report_error("Greska u liniji "+tleft+": levi operand mora oznacavati promenljivu, element niza ili polje unutar objekta",null);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // designator_stmt ::= designator LPAREN NT$3 act_pars RPAREN SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		 // obrada stvarnih parametara nije implementirana
	  // TO DO
	  
		if (o.getKind()!=Obj.Meth )
			parser.report_error("Greska u liniji "+oleft+": Ocekivan metod",null);
		if(o.getLevel() != parser.actParsNum){
			parser.report_error("Greska u liniji "+oleft+": broj parametara se razlikuje",null);
		}
		
		
		//int dest_adr=o.adr-Code.pc; // racunanje relativne adrese 
		//Code.put(Code.call); 
		//Code.put2(dest_adr);
		if (o.getType()!=Tab.noType ){
			//Code.put(Code.pop); // rezultat poziva nece biti koriscen
		}
		
		actParamList = null;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // NT$3 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

		parser.actParsNum = 0;
		
		actParamList = o.getLocals();
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // designator_stmt ::= designator LPAREN RPAREN SEMI 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		 
		if (o.getKind()!=Obj.Meth )
			parser.report_error("Greska u liniji "+oleft+": Ocekivan metod",null);
		//int dest_adr=o.adr-Code.pc; // racunanje relativne adrese 
		//Code.put(Code.call); 
		//Code.put2(dest_adr);
		//if (o.getType()!=Tab.noType )
			//Code.put(Code.pop); // rezultat poziva nece biti koriscen
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // designator_stmt ::= designator ASSIGNMENT expr SEMI 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		if( o.getKind() == Obj.Elem || o.getKind() == Obj.Var){
			if ( t.assignableTo(o.getType()) ){
				//Code.store(o);
			}
			else
				parser.report_error("Greska u liniji "+oleft+": nekompatibilni tipovi za dodelu",null);
		} else
			parser.report_error("Greska u liniji "+oleft+": levi operand mora oznacavati promenljivu, element niza ili polje unutar objekta",null);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // matched ::= WHILE LPAREN cond RPAREN matched 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // matched ::= IF LPAREN cond RPAREN matched ELSE matched 
            {
              Object RESULT =null;
		  
	  if(parser.mainMethod) parser.mainStatmentNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // matched ::= LBRACE stmt_list RBRACE 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // matched ::= PRINT LPAREN expr COMMA NUMBER RPAREN SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		  
	  if(parser.mainMethod) {
		parser.mainStatmentNum--;
		parser.mainFunctionCallNum++;
	  }
	  
	  if (t != Tab.intType && t!=Tab.charType ) {
			parser.report_error("Greska u liniji "+tleft+": tip izraza mora biti int ili char",null);
		}
		
		
		// TO DO!!
		// generisanje koda
		if (t == Tab.intType) {
			//Code.loadConst(5); // sirina ispisa na e-stek, expr je vec na e-steku
			//Code.put(Code.print);
		} else {
			//Code.loadConst(1); // sirina ispisa na e-stek, expr je vec na e-steku
			//Code.put(Code.bprint);
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // matched ::= PRINT LPAREN expr RPAREN SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		  
	  if(parser.mainMethod) {
		parser.mainStatmentNum--;
		parser.mainFunctionCallNum++;
	  }
	  
		if (t != Tab.intType && t!=Tab.charType) {
	                   parser.report_error("Greska u liniji "+tleft+": tip izraza mora biti int ili char",null);
		}
		
		// generisanje koda
		if (t == Tab.intType) {
			//Code.loadConst(5); // sirina ispisa na e-stek, expr je vec na e-steku
			//Code.put(Code.print);
		} else {
			//Code.loadConst(1); // sirina ispisa na e-stek, expr je vec na e-steku
			//Code.put(Code.bprint);
		}
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // matched ::= READ LPAREN designator RPAREN SEMI 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	  if(parser.mainMethod) {
		parser.mainStatmentNum--;
		parser.mainFunctionCallNum++;
	  }
	  if(!(t.getKind() == Obj.Fld || t.getKind() == Obj.Elem || t.getKind() == Obj.Var)){
			parser.report_error("Greska u liniji "+tleft+": operand mora oznacavati promenljivu, element niza ili polje unutar objekta",null);
	  }
	  
	  if (t.getType() != Tab.intType && t.getType() !=Tab.charType ) {
	                   parser.report_error("Greska u liniji "+tleft+": tip izraza mora biti int ili char",null);
		}
 	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // matched ::= RETURN expr SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		
		returnExists=true;
		if (isVoid){ //method_type==Tab.noType
			parser.report_error("Greska u liniji "+lleft+
						": metod ne sme imati return"+
						" sa izrazom jer je deklarisan sa void",null);
		}
		
		 
		if (!t.assignableTo(method_type))
			parser.report_error("Greska u liniji "+lleft+": tip izraza nekompatibilan sa deklaracijom metoda",null);
		
		//generisanje koda	
		//Code.put(Code.exit);
		//Code.put(Code.return_);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // matched ::= RETURN SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		
		returnExists=true;
		if (!isVoid){ //method_type!=Tab.noType
			parser.report_error("Greska u liniji "+lleft+
							": metod mora imati return iskaz"+
							" sa izrazom jer nije deklarisan sa void",null);
		}
		 
		// generisanje koda
		//Code.put(Code.exit);
		//Code.put(Code.return_);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // matched ::= BREAK SEMI 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // matched ::= designator_stmt 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("matched",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // unmatched ::= WHILE LPAREN cond RPAREN unmatched 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("unmatched",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // unmatched ::= IF LPAREN cond RPAREN matched ELSE unmatched 
            {
              Object RESULT =null;
		
	  if(parser.mainMethod)parser.mainStatmentNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unmatched",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // unmatched ::= IF LPAREN cond RPAREN statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("unmatched",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // statement ::= error 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do } u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // statement ::= unmatched 
            {
              Object RESULT =null;
		
	  if(parser.mainMethod)parser.mainStatmentNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // statement ::= matched 
            {
              Object RESULT =null;
		
	  if(parser.mainMethod)parser.mainStatmentNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // stmt_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt_list",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // stmt_list ::= stmt_list statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt_list",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // parameter ::= type IDENT LSQUARE RSQUARE 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		RESULT = Tab.insert(Obj.Var, id, idleft, new Struct(Struct.Array, t));
		
		Obj o = Tab.find(id); 
		o.setFpPos(parser.formParsNum);
		o.setAdr(parser.formParsNum);
		
		parser.formParsNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // parameter ::= type IDENT 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		if(t.getKind() == Struct.Class){
			parser.report_error("Greska u liniji "+idleft+" nisu podrzane klase kao formalni parametri",null);
		}
		
		RESULT = Tab.insert(Obj.Var, id, idleft, t); 
		
		Obj o = Tab.find(id); 
		o.setFpPos(parser.formParsNum);
		o.setAdr(parser.formParsNum);
		
		parser.formParsNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // parameter_list ::= parameter 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_list",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // parameter_list ::= parameter_list COMMA parameter 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_list",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // form_pars ::= 
            {
              Obj RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("form_pars",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // form_pars ::= parameter_list 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Obj t = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("form_pars",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // method_dec ::= return_type_ident LPAREN NT$2 form_pars RPAREN local_var_list LBRACE stmt_list RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		
			parser.mainClassMethodNum++;
			
			if (!isVoid && !returnExists) { 
			             parser.report_error("Greska u liniji "+oleft+": Metod mora imati return"+
 								" iskaz jer nije deklarisan sa void",null);
 			}
			returnExists=false;
			o.setLevel(parser.formParsNum);
			o.setLocals(Tab.topScope.locals);
			Tab.closeScope();
			
	   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("method_dec",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$2 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

			parser.formParsNum = 0;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // return_type_ident ::= VOID IDENT 
            {
              Obj RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
            	isVoid=true; 
				method_type = Tab.noType;
				RESULT = Tab.insert( Obj.Meth, id, idleft, Tab.noType); 
				Tab.openScope(); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_type_ident",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // return_type_ident ::= type IDENT 
            {
              Obj RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
				isVoid = (t == Tab.noType );
				method_type = t;
				RESULT = Tab.insert( Obj.Meth, id, idleft, t); 
				Tab.openScope(); 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_type_ident",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // method_declaration_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("method_declaration_list",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // method_declaration_list ::= method_declaration_list method_dec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("method_declaration_list",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // local_var_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("local_var_list",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // local_var_list ::= local_var_list var_dec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("local_var_list",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // var_part ::= IDENT 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		if(parser.mainMethod) parser.mainVarNum++;
		parser.varNum++;
		
		Tab.insert(Obj.Var, id, idleft, var_type); 
		
		
     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_part",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // var_part ::= IDENT LSQUARE RSQUARE 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		parser.arrayNum++;
		
		Tab.insert(Obj.Var, id, idleft, new Struct(Struct.Array, var_type));
     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_part",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // var_list ::= var_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_list",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // var_list ::= var_list COMMA var_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_list",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // var_dec ::= error SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do ; u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_dec",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // var_dec ::= type NT$1 var_list SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_dec",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // NT$1 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 var_type=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // class_dec ::= CLASS error RBRACE 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do } u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("class_dec",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // class_dec ::= CLASS IDENT LBRACE local_var_list RBRACE 
            {
              Object RESULT =null;
		
		parser.classNum++;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("class_dec",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // const_dec ::= FINAL error SEMI 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 parser.report_error("Izvrsen oporavak do ; u liniji "+lleft,null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("const_dec",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // const_dec ::= FINAL type NT$0 IDENT ASSIGNMENT rhs SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Obj t1 = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	   parser.globalConstNum++;
	   
	   Tab.insert(Obj.Con, id, idleft, var_type);
	   
	   Obj o = Tab.find(id);
	   o.setAdr(t1.getAdr());

		if ( t.assignableTo(t1.getType()) ){
			//Code.store(o);
		}
		else
			parser.report_error("Greska u liniji "+tleft+": nekompatibilni tipovi za dodelu",null);
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("const_dec",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // NT$0 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 var_type=t; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // rhs ::= CHARCONST 
            {
              Obj RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Character c = (Character)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	Obj o = new Obj(Obj.Con, "", Tab.charType);
		//o.adr=c.charValue(); Code.load(o); 
		o.setAdr(c.charValue());
		RESULT=o; 
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rhs",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // rhs ::= NUMBER 
            {
              Obj RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 	Obj c = new Obj(Obj.Con, "", Tab.intType);
			//c.adr=i.intValue(); Code.load(c); 
			c.setAdr(i.intValue());
			RESULT=c; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rhs",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // type ::= IDENT 
            {
              Struct RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 Obj novi=Tab.find(id);
                if (novi.getKind() == Obj.Type )
                   RESULT = novi.getType();
                else {
                   parser.report_error("Greska u liniji "+idleft+" ("+id+") nije tip",null);
                   RESULT=Tab.noType;
               }
         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declaration_part ::= var_dec 
            {
              Object RESULT =null;
		
		   parser.globalVarNum += parser.varNum;
		   parser.varNum = 0;
		   parser.globalArrayNum += parser.arrayNum;
		   parser.arrayNum = 0;
		 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_part",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declaration_part ::= class_dec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_part",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaration_part ::= const_dec 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_part",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // declaration_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_list",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // declaration_list ::= declaration_list declaration_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_list",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // prog_id ::= IDENT 
            {
              Obj RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		
		RESULT = Tab.insert(Obj.Prog,id,Tab.noType);
        Tab.openScope(); 
		 
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("prog_id",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // program ::= CLASS prog_id declaration_list LBRACE method_declaration_list RBRACE 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
		parser.classNum++;
		
		o.setLocals(Tab.topScope.locals);
        Tab.closeScope();
		
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

